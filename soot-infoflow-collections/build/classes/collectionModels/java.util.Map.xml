<?xml version="1.0" ?>

<collectionModel class="java.util.Map" type="value">
    <method subsig="void clear()">
        <!-- StubDroid is also able to handle this
             TODO: do we need remove all for other data structures? -->
        <remove field="[java.util.Map: java.lang.Object[] values]">
            <key idx="all" />
        </remove>
    </method>
    <method subsig="java.lang.Object compute(java.lang.Object,java.util.function.BiFunction)">
        <compute field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
            <callback idx="1" />
            <callbackBase idx="1" />
            <return />
        </compute>
    </method>
    <method subsig="java.lang.Object computeIfPresent(java.lang.Object,java.util.function.BiFunction)">
        <compute field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
            <callback idx="1" />
            <callbackBase idx="1" />
            <return />
        </compute>
    </method>
    <method subsig="java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)">
        <compute field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
            <callback idx="1" />
            <return />
        </compute>
    </method>
    <!-- boolean containsKey(java.lang.Object) fallbacks -->
    <method subsig="boolean containsValue(java.lang.Object)">
        <!-- intentionally identity for now -->
    </method>
    <!-- entrySet() fallbacks -->
    <!-- equals() fallbacks -->
    <method subsig="java.lang.Object get(java.lang.Object)">
        <access field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
        </access>
    </method>
    <method subsig="java.lang.Object getOrDefault(java.lang.Object,java.lang.Object)">
        <access field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
        </access>
        <copy mode="update">
            <from idx="1" />
            <to idx="return" />
        </copy>
    </method>
    <!-- hashCode() fallbacks -->
    <!-- isEmpty() fallbacks -->
    <!-- keySet() fallbacks -->
    <method subsig="java.lang.Object merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)">
        <compute field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
            <data idx="1" />
            <callback idx="2" />
            <callbackBase idx="0" />
            <callbackData idx="1" />
            <return />
        </compute>
    </method>
    <method subsig="java.lang.Object put(java.lang.Object,java.lang.Object)">
        <remove field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
        </remove>
        <access field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
        </access>
        <insert field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
            <data idx="1" />
        </insert>
    </method>
    <method subsig="void putAll(java.util.Map)">
        <copy mode="update">
            <from idx="0" />
            <to idx="base" />
        </copy>
    </method>
    <method subsig="java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object)">
        <access field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
        </access>
        <insert field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
            <data idx="1" />
        </insert>
        <copy mode="update">
            <from idx="1" />
            <to idx="return" />
        </copy>
    </method>
    <method subsig="java.lang.Object remove(java.lang.Object)">
        <remove field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
        </remove>
        <access field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
        </access>
    </method>
    <method subsig="boolean remove(java.lang.Object,java.lang.Object)">
        <!-- intentionally identity because we don't reason about equality of the values -->
    </method>
    <method subsig="java.lang.Object replace(java.lang.Object,java.lang.Object)">
        <remove field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
        </remove>
        <access field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
        </access>
        <insert field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
            <data idx="1" />
        </insert>
    </method>
    <method subsig="java.lang.Object replace(java.lang.Object,java.lang.Object,java.lang.Object)">
        <!-- no remove operation because we don't reason about value equality -->
        <!-- no access because doesn't seem to be relevant -->
        <insert field="[java.util.Map: java.lang.Object[] values]">
            <key idx="0" />
            <data idx="1" />
        </insert>
    </method>
    <method subsig="void replaceAll(java.util.function.BiFunction)">
        <compute field="[java.util.Map: java.lang.Object[] values]">
            <key idx="all" />
            <callback idx="0" />
            <callbackBase idx="1" />
        </compute>
    </method>
</collectionModel>
