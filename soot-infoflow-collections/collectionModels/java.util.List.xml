<?xml version="1.0" ?>

<collectionModel class="java.util.List" type="position">
    <method subsig="boolean add(java.lang.Object)">
        <insert field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="last" />
            <data idx="0" />
        </insert>
    </method>
    <method subsig="void add(int,java.lang.Object)">
        <insert field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="0" />
            <data idx="1" />
        </insert>
        <shiftRight field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="0" />
        </shiftRight>
    </method>
    <method subsig="boolean addAll(java.util.Collection)">
        <insert field="[java.util.Collection: java.lang.Object[] innerArray]" mode="append">
            <index idx="last" />
            <data idx="0" />
        </insert>
    </method>
    <method subsig="void clear()">
        <remove field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="all" />
        </remove>
    </method>
    <!-- contains() handled with fallback -->
    <!-- containsAll() handled with fallback -->
    <method subsig="java.lang.Object get(int)">
        <access field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="0" />
        </access>
    </method>
    <!-- hashCode() handled with fallback -->
    <!-- indexOf() handled with fallback -->
    <!-- isEmpty() handled with fallback -->
    <method subsig="java.util.Iterator iterator()">
        <invalidate field="[java.util.Collection: java.lang.Object[] innerArray]">
            <target idx="base" />
            <return field="[java.util.Iterator: java.lang.Object innerCollection]"
                    type="[java.lang.Object]" />
        </invalidate>
    </method>
    <!-- lastIndexOf() handled with fallback -->
    <!-- listIterator() handled with fallback -->
    <method subsig="java.util.ListIterator listIterator()">
        <invalidate field="[java.util.Collection: java.lang.Object[] innerArray]">
            <target idx="base" />
            <return field="[java.util.Iterator: java.lang.Object innerCollection]"
                    type="[java.lang.Object]" />
        </invalidate>
    </method>
    <method subsig="java.util.ListIterator listIterator(int)">
        <invalidate field="[java.util.Collection: java.lang.Object[] innerArray]">
            <target idx="base" />
            <return field="[java.util.Iterator: java.lang.Object innerCollection]"
                    type="[java.lang.Object]" />
        </invalidate>
    </method>
    <method subsig="java.lang.Object remove(int)">
        <remove field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="0" />
        </remove>
        <shiftLeft field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="0" />
        </shiftLeft>
        <access field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="0" />
        </access>
    </method>
    <method subsig="boolean remove(java.lang.Object)">
        <!-- We cannot remove any element but might shift -->
        <shiftLeft field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="all" />
        </shiftLeft>
    </method>
    <method subsig="boolean removeAll(java.util.Collection)">
        <invalidate field="[java.util.Collection: java.lang.Object[] innerArray]">
            <target idx="base" />
        </invalidate>
    </method>
    <method subsig="void replaceAll(java.util.function.UnaryOperator)">
        <compute field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="all" />
            <callback idx="0" />
            <callbackBase idx="0" />
        </compute>
    </method>
    <method subsig="boolean retainAll(java.util.Collection)">
        <invalidate field="[java.util.Collection: java.lang.Object[] innerArray]">
            <target idx="base" />
        </invalidate>
    </method>
    <method subsig="java.lang.Object set(int,java.lang.Object)">
        <remove field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="0" />
        </remove>
        <access field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="0" />
        </access>
        <insert field="[java.util.Collection: java.lang.Object[] innerArray]">
            <index idx="0" />
            <data idx="1" />
        </insert>
    </method>
    <!-- size() handled with fallback -->
    <method subsig="void sort(java.util.Comparator)">
        <invalidate field="[java.util.Collection: java.lang.Object[] innerArray]">
            <target idx="base" />
        </invalidate>
    </method>
    <method subsig="java.util.Spliterator spliterator()">
        <invalidate field="[java.util.Collection: java.lang.Object[] innerArray]">
            <target idx="base" />
            <return field="[java.util.Collection: java.lang.Object[] innerArray]"
                    type="[java.lang.Object[]]" />
        </invalidate>
    </method>
    <method subsig="java.util.List subList(int,int)">
        <invalidate field="[java.util.Collection: java.lang.Object[] innerArray]">
            <target idx="base" />
            <return field="[java.util.Collection: java.lang.Object[] innerArray]"
                    type="[java.lang.Object[]]" />
        </invalidate>
    </method>
    <!-- toArray() handled with fallback -->
</collectionModel>
